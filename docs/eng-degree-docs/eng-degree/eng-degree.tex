\documentclass[12pt, a4paper, twoside, openany]{book}
\usepackage[
    a4paper, 
    total={6in, 8in}, 
    top=2cm,
    left=3cm,
    right=2.5cm,
    bottom=1.25cm,
    includeheadfoot,
    headheight=40pt,
]{geometry}
\usepackage[T1]{polski}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{mathptmx}
\usepackage{enumitem}
\usepackage[utf8]{inputenc}
\usepackage{import}
\usepackage{setspace}
\usepackage{titlesec}
\usepackage{multirow}
\usepackage{longtable}
\usepackage{url}
\usepackage{indentfirst}
\usepackage{tabularray}

\import{../}{commands.tex}

\fancypagestyle{plain}{
    \fancyhf{}
    \renewcommand{\headrulewidth}{0pt}
    \fancyhead[C]{\uniimage}
    \fancyfoot[LE,RO]{\thepage}
}

% Wymogi edycyjne: https://moodle2.e-wsb.pl/pluginfile.php/7505508/mod_resource/content/2/Wymogi%20edycyjne_praca%20dyplomowa.pdf

\NewTblrTheme{fancy}{
    \SetTblrStyle{firsthead}{foot=\bfseries}
    \SetTblrStyle{firstfoot}{fg=blue2}
    \SetTblrStyle{middlefoot}{\itshape}
    \SetTblrStyle{caption-tag}{red2}
}

\DefTblrTemplate{contfoot-text}{normal}{Kontynuowane na następnej stronie}
\SetTblrTemplate{contfoot-text}{normal}
\DefTblrTemplate{conthead-text}{normal}{(Kontynuacja)}
\SetTblrTemplate{conthead-text}{normal}

\renewcommand\thesection{\Alph{chapter}\arabic{section}}

\addtolength{\topmargin}{-34.91641pt}

\linespread{1.5}

\setlist[itemize]{label=--}

\begin{document}

% Header & footer settings :)
\pagestyle{plain}

\titleformat
{\chapter} %/{〈command 〉}
[block] %/[〈shape〉]
{\bfseries\large} %/ {〈format〉}
{} %/ {〈label 〉}
{0.5ex} %/ {〈sep〉}
{
    \centering
} %/ {〈before-code〉}
{
    \vspace{-0.5ex}%
} %/ {〈after-code〉}

\setcounter{secnumdepth}{4}

\titleformat{\section}[hang]{\normalfont\bfseries}{\thesection.}{0.5em}{}

\titleformat{\subsection}[hang]{\normalfont\bfseries}{\thesubsection.}{0.4em}{}

\titleformat{\subsubsection}[hang]{\normalfont\bfseries}{\thesubsubsection.}{0.4em}{}

\begin{titlepage}
    \begin{center}

        \uniimage

        \MakeUppercase{\department}

        \vspace{5cm}

        \begin{Large} \textbf{\topic} \end{Large}

        \vspace{5cm}

        PROJEKT DYPLOMOWY

        \vfill
        Poznań 2023

    \end{center}
\end{titlepage}

\setcounter{tocdepth}{3}

\chapter{\MakeUppercase{dane partnerów}}

\section{Dane Promotora}

\noindent
\begin{tabular}{ |p{5cm}|p{7cm}|}
    \hline
    Imię i nazwisko         & Izabela Janicka-Lipska \\
    \hline
    Stopień / Tytuł naukowy & dr inż.               \\
    \hline
    Data i podpis           &                        \\ \hline
\end{tabular}

\section{Dane członków Zespołu projektu}

\membersTable


% Example table and figure formatting
\section{Wprowadzenie}
W dzisiejszym świecie, kiedy problem zanieczyszczenia środowiska staje się coraz bardziej palący, zarządzanie odpadami staje się kluczowym aspektem naszego życia. Statystyki nie pozostawiają złudzeń - rosnąca produkcja odpadów na skalę globalną stawia przed nami istotne wyzwania. Na całym świecie rocznie wytwarza się ogromne ilości odpadów, z których część jest nadal nieefektywnie zagospodarowana, co prowadzi do negatywnego wpływu na środowisko naturalne. W samej Polsce, roczna produkcja odpadów na rok 2021 wyniosła 121 milionów ton, z czego 11.3\% stanowiły odpady komunalne. \footnote{s. 149; Główny Urząd Statystyczny - Ochrona środowiska 2022, Warszawa, 2022r.}.

Jednym z kluczowych aspektów tego wyzwania jest efektywne segregowanie i recykling odpadów, co przyczynia się nie tylko do ochrony środowiska naturalnego, ale także do potencjalnych oszczędności. Jak podaje EEA (Europejska Agencja Ochrony Środowiska), na obywatela Unii Europejskiej przypada średnio 4,8 ton odpadów komunalnych, z czego 49\% jest recyklingowanych \footnote{Dane za stroną internetową (dostęp: 03.11.2023r.) \url{https://www.eea.europa.eu/en/topics/in-depth/waste-and-recycling}}. Recykling może przynieść znaczące korzyści gospodarcze i środowiskowe, w tym zmniejszenie emisji gazów cieplarnianych, ograniczenie zużycia surowców naturalnych oraz tworzenie miejsc pracy. W samej Polsce, między latami 2004 i 2020, procent recyklingu odpadów komunalnych wzrósł z poziomu 4,9 do 38.7\%.

\begin{figure}[h]
    \caption{Poziom recyklingu odpadów komunalnych w krajach Unii Europejskiej.}
    \centering\includegraphics[width=12cm]{./static/Municipal waste recycling rates in Europe by country.png}\\
    Źródło: Dane za stroną internetową (dostęp: 03.11.2023r.) \url{https://www.eea.europa.eu/en/topics/in-depth/waste-and-recycling}
\end{figure}

% TODO: Znaleźć badania na ten temat, zacytować - @kuba
Jednakże, aby skutecznie promować segregację odpadów i recykling, niezbędne jest zrozumienie ludzkiego zachowania oraz eliminacja "tarcia" związanego ze znalezieniem odpowiedniego pojemnika na odpady. Projekt oferujący łatwy dostęp do informacji o pojemnikach na odpady oraz lokalizacji najbliższego odpowiedniego kontenera usuwa bariery, które często zniechęcają do segregacji. Behawioryka sugeruje, że ludzie są podatni na wpływ norm społecznych i nacisku społeczności lokalnej, co stanowi kolejny argument za promowaniem proekologicznych norm i społecznego zaangażowania.

Niniejsza praca inżynierska skupia się na rozwiązaniu tego wyzwania poprzez wykorzystanie zaawansowanych technologii, takich jak sztuczna inteligencja, uczenie maszynowe, technologie wizyjne oraz geolokalizacja, w celu stworzenia systemu automatycznej klasyfikacji pojemników na odpady oraz aplikacji mobilnej, która umożliwia łatwiejsze lokalizowanie pojemników na śmieci w najbliższej okolicy. Naszym celem jest nie tylko zwiększenie efektywności gospodarki odpadami, ale także kształtowanie proekologicznego zachowania i eliminacja barier, które utrudniają segregację odpadów.

\chapter{\MakeUppercase{Założenia projektu}}

\section{Opis Projektu}

\subsection{Uzasadnienie wyboru tematu}

Problem utylizacji odpadów stał się w ostatnich latach jednym z największych wyzwań dla społeczeństwa i środowiska naturalnego. Śmieci są produkowane w ogromnych ilościach, a nieprawidłowe postępowanie z nimi prowadzi do skażenia powietrza, wody i gleby. W związku z tym, istnieje potrzeba opracowania rozwiązań, które ułatwią zarządzanie odpadami w sposób bardziej skuteczny i zrównoważony.

Dzięki rozwojowi technologii uczenia maszynowego, pojawiła się możliwość stworzenia aplikacji mobilnej, która rozpoznawać będzie pojemniki na odpady na podstawie zdjęć oraz oznaczać je na mapie. Ułatwi ona lokalizowanie pojemników na dany typ odpadów oraz proces właściwego utylizowania śmieci dla użytkowników. Taka aplikacja może również zwiększyć świadomość społeczną w zakresie utylizacji odpadów i przyczynić się do zmniejszenia ilości odpadów zalegających na składowiskach.

Temat ten jest aktualny i ważny, a jednocześnie daje wiele możliwości na zastosowanie różnych technologii i algorytmów uczenia maszynowego. Przy realizacji projektu można wykorzystać m.in. sieci neuronowe, algorytmy uczenia głębokiego, przetwarzanie obrazów, uczenie maszynowe w chmurze oraz usługi geolokalizacyjne.

Podsumowując, projekt \topic jest uzasadniony ze względu na aktualność i ważność tematu, możliwość wykorzystania najnowszych technologii oraz potencjalne korzyści dla społeczeństwa i środowiska naturalnego.

\subsection{Problem badawczy}

Problemem badawczym jest określenie algorytmów uczenia maszynowego najlepiej nadających się do rozpoznawania pojemników na odpady na podstawie zdjęć oraz określenie cech obrazów odpowiadających za skuteczność modelu.

W ramach tego problemu badawczego można skoncentrować się na kilku podproblemach, m.in.:
\begin{itemize}
    \item analiza dostępnych zbiorów danych:
          \begin{itemize}
              \item znalezienie zbiorów danych do treningu i testowania modelu rozpoznawania pojemników na odpady;
              \item określenie jak są one zdefiniowane oraz jakie informacje zawierają;
          \end{itemize}
    \item wybór odpowiednich algorytmów uczenia maszynowego:
          \begin{itemize}
              \item określenie algorytmów uczenia maszynowego, które najlepiej nadają się do rozpoznawania pojemników na odpady na podstawie zdjęć;
          \end{itemize}
    \item przygotowanie zbiorów danych:
          \begin{itemize}
              \item zastosowanie technik przetwarzania obrazów;
              \item potencjalne użycie technik augmentacji danych;
          \end{itemize}
    \item implementacja i trening modelu: wyłonienie najlepszej techniki trenowania modelu bazowanego na obrazach;
    \item ocena skuteczności modelu: określenie metryk, które pozwolą dokładnie ocenić skuteczność modelu w rozpoznawaniu pojemników na odpady;
    \item analiza cech obrazów: na podstawie analizy modelu, zlokalizowanie cech obrazów odpowiadających za skuteczność procesu rozpoznawania pojemników na odpady.
\end{itemize}

\subsection{Cel główny i cele szczegółowe projektu}

Celem nadrzędnym jest stworzenie aplikacji mobilnej, która będzie pomagać użytkownikom w identyfikacji oraz lokalizowaniu pojemników na odpady danego typu. Aplikacja ta będzie miała na celu wspomaganie procesu utylizacji odpadów w odpowiedzialny i racjonalny sposób poprzez ułatwienie segregacji odpadów oraz zapobieganie ich niewłaściwemu składowaniu.

Cele podrzędne:
\begin{itemize}
    \item analiza dostępnych zbiorów danych: analiza zbiorów danych dostępnych w Internecie, które mogą posłużyć do treningu i testowania modelu rozpoznawania pojemników na odpady;
    \item wybór odpowiednich algorytmów uczenia maszynowego najlepiej nadających się do rozpoznawania pojemników na odpady na podstawie zdjęć;
    \item przygotowanie zbiorów danych do treningu modelu rozpoznawania pojemników na odpady;
    \item implementacja i trening modelu rozpoznawania pojemników na odpady;
    \item ocena skuteczności modelu rozpoznawania pojemników na odpady;
    \item analiza cech obrazów odpowiadających za skuteczność procesu rozpoznawania pojemników na odpady;
    \item określenie, które cechy obrazów mają największy wpływ na skuteczność procesu rozpoznawania i jak można je wykorzystać do dalszej optymalizacji modelu.
\end{itemize}

\subsection{Zakres podmiotowy, przedmiotowy, czasowy i przestrzenny}

\begin{itemize}
    \item Zakres podmiotowy projektu \topic  obejmuje badanie i opracowanie aplikacji mobilnej oraz algorytmów uczenia maszynowego, które umożliwią rozpoznawanie pojemników na odpady. Podmiotem badania jest zatem aplikacja mobilna Trashify oraz modele uczenia maszynowego, które będą umożliwiać rozpoznawanie pojemników na odpady.
    \item Zakres przedmiotowy obejmuje badanie możliwości rozpoznawania różnych typów pojemników na odpady (np. pojemnik na papier, szkło, plastik, odpady organiczne itp.) oraz opracowanie algorytmów uczenia maszynowego, które umożliwią ich poprawną identyfikację. W ramach projektu będzie również opracowana aplikacja mobilna, która będzie integrować te algorytmy oraz udostępniać użytkownikom informacje o pojemnikach na odpady oraz umożliwiać im łatwe i szybkie ich zlokalizowanie.
    \item Zakres czasowy projektu obejmuje okres od 01.04.2023 aż do 01.12.2023.
    \item Zakres przestrzenny projektu obejmuje miejsce, w którym aplikacja Trashify będzie wykorzystywana, czyli przede wszystkim Polska. Projekt ogranicza się do konkretnego obszaru geograficznego, ponieważ algorytmy uczenia maszynowego, które zostaną opracowane w ramach projektu, będą skupiały się na pojemnikach na odpady spotykanych w Polsce. W ramach projektu nie będzie prowadzona analiza pojemników spotykanych w innych krajach.
\end{itemize}

\subsection{Metody i techniki badawcze}
\begin{itemize}
    \item Metoda analizy i konstrukcji logicznej:
          \begin{itemize}
              \item analiza składników aplikacji Trashify (np. interfejs użytkownika, algorytmy uczenia maszynowego, baza danych itp.);
              \item indywidualna analiza każdego z tych składników,
                    synteza wyników analizy w celu stworzenia spójnego i logicznego systemu informacyjnego.
          \end{itemize}
    \item Metoda statystyczna:
          \begin{itemize}
              \item badanie preferencji użytkowników w zakresie korzystania z aplikacji mobilnej Trashify na ograniczonej próbie;
              \item pozyskanie informacji o średniej ilości odpadów segregowanych przez użytkowników korzystających z aplikacji;
              \item analiza zależności pomiędzy poszczególnymi cechami użytkowników a ich zachowaniem w kontekście segregacji odpadów.
          \end{itemize}
    \item Metoda symulacji komputerowej:
          \begin{itemize}
              \item wykorzystanie algorytmów uczenia maszynowego do stworzenia modelu rozpoznającego typ pojemnika na odpady;
              \item przeprowadzenie symulacji na tym modelu, celem zbadania różnych czynników na jego dokładność (np. rozdzielczość zdjęcia, kąt pod jakim zostało ono wykonane, oświetlenie itp.).
          \end{itemize}
    \item Metoda heurystyczna:
          \begin{itemize}
              \item analiza problemów i wyzwań związanych z korzystaniem z aplikacji Trashify i sortowaniem odpadów przez użytkowników;
              \item odkrywanie nowych rozwiązań i podejść do tych problemów;
              \item badanie opinii użytkowników i na ich podstawie wprowadzanie ulepszeń w aplikacji.
          \end{itemize}
\end{itemize}

\section{Ryzyko związane z realizacją projektu}

\begin{enumerate}[label=--]
    \item Ryzyko technologiczne -- związane z wykorzystaniem nowych technologii, które mogą nie działać zgodnie z oczekiwaniami, bądź w trakcie projektowania i implementacji systemu, mogą pojawić się trudności techniczne.
    \item Ryzyko projektowe -- związane z niedostatecznymi planami, wyboru niewłaściwej metodyki lub zła interpretacja wymagań.
    \item Ryzyko jakościowe -- związane z niedostatecznymi testami, błędami w kodzie, które mogą prowadzić do awarii systemu, co może prowadzić do opóźnień w realizacji projektu.
    \item Ryzyko bezpieczeństwa -- związane z atakami cybernetycznymi na system, które mogą prowadzić do utraty danych lub przestojów w działaniu systemu.
\end{enumerate}

\chapter{Realizacja}

\section{Opracowanie projektu}

\subsection{Decyzje architektoniczne}

Na etapie planowania pracy projektowej kluczowym jest dobranie odpowiednich narzędzi
do poszczególnych elementów aplikacji. Z tego względu zespół zdecydował się na stworzenie
dokumentacji decyzji architektonicznych, w których opisano decyzję, plusy oraz minusy wybranch rozwiązań. \footnote{s. 48; Markdown Architectural Decision Records: Format and Tool Support; Oliver Kopp, Anita Armbruster, Olaf Zimmermann, Institute for Parallel and Distributed Systems, University of Stuttgart, 2018r.}

\subsubsection{Aplikacja serwerowa}

Aplikacja serwerowa jest kluczowym elementem niemalże każdego projektu aplikacji
internetowej, czy mobilnej. Służy ona jako bezpieczne środowisko do przechowywania danych
użytkowników oraz przeprowadzania skomplikowanych operacji zbyt wymagających i/lub
niebezpiecznych dla środowisk klienckich.

Przy projektowaniu aplikacji kluczowym było dobranie odpowiednich narzędzi do
poszczególnych elementów pracy, takich jak:
\begin{itemize}
    \item język programowania wykorzystany do projektowania aplikacji;
    \item framework serwerowy;
    \item testy jednostkowe i integracyjne;
    \item testy e2e;
    \item baza danych;
    \item budowniczy kwerend, dedykowane mapery obiektowo-relacyjne badź mapery obiektowo-dokumentowe;
\end{itemize}

\paragraph{Język programowania wykorzystany do projektowania aplikacji serwerowej\\}

Z uwagi na znajomość tego języka wśród członków zespołu wybraliśmy język JavaScript
po stronie aplikacji serwerowej.

Aplikacja serwerowa uruchamiana jest w środowisku uruchomieniowym Node.js, które bazowane jest na
silniku V8 stworzonym przez firmę Google LLC.

\paragraph{Dobór frameworka aplikacji serwerowej}
\subparagraph{Framework serwerowy\\}

Framework jest zestawem dopasowanych narzędzi do stworzenia konkretnego rozwiązania.\footnote{s. 1; Server-Centric Web Frameworks: An Overview; Iwan Vosloo and Derrick G. Kourie, University of Pretoria, ACM Computing Surveys, Vol. 40, No. 2, Artykuł 4, 2008r.}
W przestrzeni środowiska Node.js na przestrzeni lat pojawiło się ich wiele, bardziej i
mniej znanych. Przypatrzyliśmy się trzem najbardziej popularnym i na bieżąco wspieranym
rozwiązaniom.

\textbf{Express} -- jeden z pierwszych frameworków dla środowiska Node.js, powstały w roku 2010.
Jest on dojrzałym, niezwykle lubianym przez społeczność rozwiązaniem, oferującym
minimalistyczny interfejs, bezstronny względem wzorców projektowych. Posiada bogaty ekosystem
oprogramowań pośredniczących tworzonych i wspieranych przez społeczność.\footnote{Dane za stroną internetową (dostęp: 14.11.2023r.) \url{https://expressjs.com/en/4x/api.html}}
Jest on pobierany średnio 30 milionów razy w tygodniu \footnote{Dane za stroną internetową (dostęp: 12.11.2023r.) \url{https://www.npmjs.com/package/express}}, co czyni go liderem w popularności.

\textbf{Fastify} -- framework zainspirowany Express oraz Hapi. Tak jak w przypadku Expressa,
jest on minimalistyczny, jednakże wprowadza kilka usprawnień oraz rozszerzeń do
konceptów w nim prezentowanych. Głównym wzorcem tego frameworka jest bogaty system
wtyczek, które zaimplementowane są na podstawie skierowanego grafu acyklicznego\footnote{Dane za stroną internetową (dostęp 14.11.2023r.)\url{https://fastify.dev/docs/latest/Guides/}}.
Każda ścieżka żądania HTTP, dekoratory, haki są traktowane jako wtyczki.
Pozwala to na pełną enkapsulację logiki oraz zwiększa bezpieczeństwo aplikacji.
Dodatkowo jest on jednym z najszybszych frameworków serwerowych w ekosystemie node.js\footnote{S. 7; Danil Demashov, Ilya Gosudarve, Efficiency Evaluation of Node.js Web-Server Frameworks, Uniwersytet ITMO, Petersburg, Rosja, 2020r.}

\begin{figure}[h]
    \caption{Reprezentacja skierowanego grafu acyklicznego}
    \includegraphics[width=6cm]{./static/ADG.png}
    \centering
    \label{fig:ADG}
\end{figure}

\textbf{NestJS} -- to framework opiniowany i jako taki wymusza na użytkowniku stosowanie określonych wzorców.
Wykorzystuje bieżące zmiany w języku JavaScript (ECMAScript), został zbudowany przy użyciu i w pełni obsługuje TypeScript oraz zawiera w sobie fragmenty
programowania obiektowego, funkcyjnego i reaktywnego programowania funkcyjnego.
W przypadku aplikacji internetowych Nest bazowo używa Express jako sterownika HTTP,
z możliwością wykorzystania Fastify, co wiąże się z dodatkowymi mankamentami. Niejako próbuje naśladować frameworki pokroju Laravela,
.NET, czy Spring, wykorzystując dekoratory niemal do każdej części aplikacji związanej z architekturą. Wprowadza to dużo abstrakcji, natomiast interfejsy API są w pełni udostępnione programistom, zapewniając uncję wolności.
Posiada dedykowany interfejs terminalowy, którego można użyć do uruchomienia projektu,
utworzenia nowego z zainstalowanymi wszystkimi zależnościami, generowania zasobów HTTP,
kontrolerów, usług, obiektów transferu danych i innych\footnote{Dane za stroną internetową (14.11.2023r.) \url{https://docs.nestjs.com/}}.

\subparagraph{Decyzja\\}

Zespół projektowy zdecydował się na wykorzystanie frameworka NestJS z wykorzystaniem
Fastify jako sterownika HTTP z uwagi na znaczną różnicę w wydajności względem sterownika Express.

Plusy oraz minusy takiej decyzji są następujące:

\begin{itemize}
    \item gotowa do wykorzystania architektura aplikacji;
    \item olbrzymia społeczność, od której można czerpać wiedzę na temat rozwiązań 
    oraz korzystać z gotowych rozwiązań popularnych problemów;
    \item mniejsza ilość kodu bazowego do napisania;
    \item prostsza separacja logiki biznesowej;
    \item ułatwione testowanie jednostkowe oraz integracyjne za pomocą wstrzykiwania
    zależności oraz dzięki wbudowanym narzędziom testowym;
    \item problematyczna implementacja rozwiązań nieprzewidzianych przez twórców
    frameworka;
    \item niski poziom kontroli nad cyklem życia żądań HTTP oraz samej architektury;
    \item komunikaty błędów mogą niewiele mówić programiście, co utrudnia proces debuggowania.
\end{itemize}

\paragraph{Architektura interfejsu programistycznego aplikacji}
\subparagraph{Interfejs aplikacji\\}
Zaprojektowanie interfejsu API, który będzie responsywny zarówno na urządzeniach mobilnych, jak i w sieci, jest wyzwaniem ze względu na nadmierne oraz niedostateczne pobieranie danych i potencjalne wykonywanie wielu żądań do serwera na urządzeniu mobilnym.
W związku z tym zespół postanowił zbadać możliwość wykorzystania GraphQL zamiast tradycyjnego RESTful API.

\textbf{GraphQL}\\
Opracowanym przez firmę Facebook (obecnie Meta), graphql jest językiem zapytań oraz środowiskiem wykonawczym do interakcji z danymi w aplikacjach, którego celem jest ograniczenie nadmiernego i niedostatecznego pobierania danych \footnote{S. 140; Gleison Brito, Thais Mombach, Marco Tulio Valente, Migrating to GraphQL: A Practical Assessment, ASERG Group, Department of Computer Science, Federal University of Minas Gerais, Brazil, 18.02.2019.}. Został zaprojektowany z myślą o urządzeniach mobilnych, biorąc pod uwagę ich niską prędkość, pamięć masową i drogie żądania internetowe.
W tym języku zapytań wszystkie żądania są wysyłane do pojedynczego punktu końcowego, a wykres danych, zwykle w formacie json, jest analizowany. Następnie zapytania są oceniane i stosowane są odpowiednie zapytania i mutacje.

Składa się on z głównych trzech części:
\begin{enumerate}
    \item Zapytań (Queries): Służą do pobierania danych z serwera. Klient definiuje, jakie informacje potrzebuje, a serwer dostarcza tylko te dane. \footnote{Dane za stroną internetową: \url{https://graphql.org/learn/queries/}, Rozdział ,,Queries and Mutations`` (dostęp: 12.11.2023r.)}
    \item Mutacji (Mutations): Pozwalają na modyfikację danych na serwerze, takie jak dodawanie, aktualizowanie lub usuwanie rekordów. \footnote{Dane za stroną internetową: \url{https://graphql.org/learn/queries/}, Rozdział ,,Queries and Mutations`` (dostęp: 12.11.2023r.)}
    \item Typów (Types): GraphQL definiuje struktury typów danych i relacje między nimi, co umożliwia klientowi zrozumienie, jakie dane mogą być dostępne i jakie zapytania można wykonywać.\footnote{Dane za stroną internetową: \url{https://graphql.org/learn/schema/}, Rozdział ,,Schemas and Types`` (dostęp: 12.11.2023r.)}
\end{enumerate}

\textbf{REST}\\
REST to akronim REpresentational State Transfer\footnote{Rozdział 5; Roy Thomas Fielding, Architectural Styles and the Design of Network-based Software Architectures, 2000r.} i styl architektoniczny dla rozproszonych systemów hipermedialnych. Sam w sobie jest wzorcem architektonicznym, który zakłada rozdzielenie odpowiedzialności między zapytaniami (GET), mutacjami (POST, PATCH, PUT) i metodami usuwania (DELETE). Został on przetestowany w boju od 2000 roku i szeroko przyjęty w społeczności programistów.

\textbf{Decyzja}\\
Zespół programistów zdecydował się wybrać REST jako abstrakcyjny interfejs aplikacji serwerowej, ze względu na:
\begin{enumerate}[label=--]
    \item ustalone normy i dużą społeczność ekspertów, od których można się uczyć;
    \item możliwość łatwego przesyłania plików, co będzie kluczowe w kontekście tej aplikacji;
    \item różnorodność dostępnych formatów wyjściowych; \footnote{Dane za stroną internetową \url{https://www.rfc-editor.org/rfc/rfc9110#field.content-type} (dostęp: 12.11.2023 r.)}
    \item możliwość kontrolowania szczegółowych uprawnień w ramach autoryzacji; \footnote{S. 1719-1722; Bojan Suzic, Bernd Prünster, Dominik Ziegler, On the structure and authorization management of RESTful web services, Graz Univeristy of Technology, Institue for Applied Information Processing and Communicationts, Graz, Austria, 2018r.}
    \item ekspresywne kody statusu odpowiedzi. \footnote{Dane za stroną internetową \url{https://www.rfc-editor.org/rfc/rfc9110#name-status-codes}}
\end{enumerate}

Ze względu na wybór RESTful API, zespół będzie musiał zmierzyć się z następującymi zaletami i wadami:

\begin{enumerate}[label=--]
    \item buforowanie będzie łatwo dostępne zarówno po stronie serwera, jak i klienta;
    \item w przypadku problemów, istnieje duża społeczność ekspertów, od których można uzyskać wskazówki;
    \item dobrze udokumentowany zestaw najlepszych praktyk;
    \item obsługa transferów plików w łatwy, ustandaryzowany sposób;
    \item możliwość zwracania odpowiedzi w wielu formatach;
    \item prostota implementacji precyzyjnej autoryzacji użytkowników;
    \item łatwiejsza obsługa błędów po stronie klienta i debugowanie aplikacji serwerowej w porównaniu do środowiska GraphQL;
    \item większa ilość tzw. ,,boilerplate'u`` do napisania - interfejsy ,,RESTful`` zwykle wymagają więcej standardowego kodu niż ich odpowiedniki GraphQL;
    \item możliwość niedostatecznego i nadmiernego pobierania danych -- zostanie to złagodzone dzięki zastosowaniu schematu JSON;
    \item aplikacja po stronie klienta może być mniej reaktywna ze względu na mnogość wywołań do serwera - zostanie to złagodzone dzięki wykorzystaniu schematu JSON i rozbudowanemu buforowaniu zarówno po stronie klienta, jak i serwera;
    \item paginacja musi zostać zaimplementowana przez deweloperów;
    \item wersjonowanie API będzie musiało być spójne.
\end{enumerate}

\paragraph{Dobór frameworka do testowania automatycznego}
\subparagraph{Testowanie aplikacji\\}

Testowanie aplikacji jest kluczową decyzją dla zespołu programistów.
Chociaż początkowo może być uważane za stratę czasu, umożliwia ono pewniejsze rozwijanie kodu, uniknianie błędów i łatwiejsze zrozumienie kodu źródłowego (z testami będącymi rodzajem dokumentacji w kodzie opisującej zachowanie danej funkcjonalności)\footnote{S. 1-4; Jiantao Pan, Software Testing, Carnegie Mellon University, Stany Zjednoczone Ameryki, Wiosna 1999}.
Zespół postanowił rozejrzeć się za opcjami i na myśl przyszły dwie najpopularniejsze: Jest oraz Mocha + Chai.

\textbf{Jest} -- popularny i pełen wbudowanych funkcjonalności framework testowy JavaScript używany głównie do testów jednostkowych stworzony przez firmę Facebook (obecnie Meta). Główne możliwości Jesta są następujące\footnote{Dane za stroną internetową (dostęp 14.11.2023r.) \url{https://jestjs.io/docs/api}}:
\begin{enumerate}[label=--]
    \item łatwa konfiguracja -- w pliku `package.json`, `.jest` lub `jest.js`. Dodatkowo, konfiguracje mogą być dostosowane do konkretnych scenariuszy i stosowane dynamicznie przez program uruchamiający testy;
    \item obsługa różnych typów testów, takich jak testy jednostkowe, integracyjne, e2e z dodatkiem bilbioteki supertest i testów migawkowych;
    \item mocking -- z wysokim stopniem dostosowania, w tym mockowanie wartości zwracanych (zarówno w funkcjach synchronicznych, jak i asynchronicznych). Są one przechowywane i mogą być walidowane;
    \item pokrycie kodu -- wbudowane narzędzie do raportowania pokrycia kodu źródłowego;
    \item testowanie równoległe - zwiększenie szybkości testowania, zwłaszcza gdy testy są w pełni niezależne i nie mutują wspólnego zestawu danych;
    \item tryb watch -- uruchamianie testów w tle wraz ze zmianami w kodzie źródłowym i/lub samych testach;
    \item test matchers -- wbudowany zestaw matcherów, które pozwalają na szybkie i wygodne sprawdzanie wyników funkcji i/lub komponentów. Obejmują one między innymi: `toEqual`, `toHaveLength`, `toContain`, `toBeTruthy`, `toBeDefined`;
    \item konfiguracja globalna -- możliwość zadeklarowania zestawu akcji lub manipulacji przed wszystkimi testami (lub określonym ich podzbiorem). Pozwala to programiście na zbudowanie konkretnego, czasochłonnego modułu lub funkcjonalności raz i operowanie na nim we wszystkich testach. Haki zadeklarowane w konfiguracji globalnej zostaną zastosowane do wszystkich zestawów testów;
    \item obsługa globalnego usuwania środowiska;
    \item haki cyklu życia testów -- są to `beforeEach()`, `beforeAll()`, `afterEach()` i `afterAll()`, które pozwalają na wykonywanie akcji w określonych punktach uruchomionych testów. Pozwala to programistom zadeklarować takie akcje raz i zastosować je do wszystkich przypadków;
    \item wsparcie dla środowisk testowych Node.js i przeglądarki;
    \item jednoczesne uruchamianie testów w danej przestrzeni (funkcja eksperymentalna).
\end{enumerate}

\textbf{Mocha z Chai} -- framework testowy Mocha\footnote{Dane za stroną internetową (dostęp 14.11.2023r.) \url{https://mochajs.org/}} z biblioteką do asercji Chai \footnote{Dane za stroną internetową (dostęp 14.11.2023r.) \url{https://www.chaijs.com/api/}}:
\begin{enumerate}[label=--]
    \item wyczerpujące i czytelne dla człowieka asercje;
    \item używane głównie w BDD (Behavior-Driven Development);
    \item obsługa haków cyklu życia `before`, `after`, `beforeEach` i `afterEach`;
    \item testowanie równoległe ma swoje dobrze zdefiniowane ograniczenia, takie jak użycie `it.only` lub `describe.only`, które są niedostępne. Testowanie równoległe jest dostępne tylko w środowisku Node.js. Haki zadeklarowane na poziomie root nie są globalne w przypadku testowania równoległego;
    \item dostępny cały zestaw reporterów, zarówno wbudowanych, takich jak `json-stream`, `markdown`, `progress`, `xunit`, `html reporter`, jak i opcji innych firm. Nie działają one dobrze z testami równoległymi, ponieważ oczekują, że Mocha będzie wiedzieć, ile testów planuje się uruchomić przed ich wykonaniem;
    \item obsługa globalnej konfiguracji za pomocą `mochaGlobalSetup`;
    \item obsługa globalnego usuwania środowiska za pomocą `mochaGlobalTeardown`;
    \item obsługa zarówno modułów ES, jak i CommonJS, z zastrzeżeniem, że moduły ES nie są obsługiwane przez tryb watch. To samo dotyczy niestandardowych raporterów i niestandardowego interfejsu;
    \item konfiguracja może być tylko plikiem CommonJS `.mocharc.js` lub `.mocharc.cjs`.
\end{enumerate}

\subparagraph{Decyzja\\}

Zespół zdecydował się na framework testowy Jest, ponieważ nie wymaga wielu dodatkowych wtyczek do spełnienia potrzeb zespołu. Ponadto ma lepsze wsparcie dla testów równoległych i posiada potężny zestaw funkcji, które umożliwią szybsze tworzenie pakietów testowych.

Plusy oraz minusy takiej decyzji są następujące:
\begin{itemize}
    \item testy będą tworzone przy użyciu dobrze ugruntowanych reguł;
    \item paczka ,,jest-plugin`` będzie musiała zostać dodana do pliku `.eslintrc` i `package.json`;
    \item jest ma olbrzymią społeczność z dużą ilością ekspertów, którzy go używają i otwarcie dzielą się wiedzą;
    \item ilość matcherów i funkcjonalności może stać się przytłaczająca i prowadzić do mniejszej produktywności;
    \item Jest z uwagi na ilość dostępnych możliwości, jak i kompatybilność wsteczną, jest obecnie jednym z najwolniejszych frameworków testowych, co znacznie zwiększy czas potrzebny do wykonania testów.
\end{itemize}

\paragraph{Dobór bazy danych}
\subparagraph{Typy baz danych\\}

\textbf{Bazy nierelacyjne (NoSQL)}\\
Bazy danych No-SQL nie mają tak sztywnego schematu bazy danych jak ich relacyjne odpowiedniki.
Struktura organizacyjna różni się w zależności od typu nierelacyjnej bazy danych\footnote{S.1; Deka Ganesha Chandra, BASE Analysis of NoSQL Database, Regional Vocational Training Instutite for Women, Tura, Meghalaya, India, 19.11.2012r.}.
Biorąc to pod uwagę, wszystkie mają na celu rozwiązanie problemów tradycyjnej, relacyjnej bazy danych, poprzez zaadresowanie kwestii elastyczności i skalowalności.
Bazy danych SQL nie są idealne do przechowywania nieustrukturyzowanych formatów danych, takich jak tekst, wideo i obrazy, co adresują bazy NoSQL.
Przedkładają one dostępność nad spójność.
Termin NoSQL nie oznacza, że dana baza danych nie obsługuje poleceń SQL (niektóre obsługują SQL), można go dokładnie podsumować jako ,,nie tylko SQL``.
Rodzaje nierelacyjnych struktur baz danych to:
\begin{enumerate}[label=--]
    \item Key-value store -- jest to model bez schematu, w którym dane są zorganizowane w słownik par klucz-wartość.
    Klucz może być podobny do tego, jaki znajduje się w relacyjnej bazie danych, np. identyfikator koszyka, podczas gdy wartości są tablicą danych, np. każdy pojedynczy element w koszyku użytkownika.
    Są one powszechnie stosowane w systemach o dużej objętości, które wymagają najszybszego możliwego czasu reakcji.
    Ze względu na nieodłączną strukturę danych, nie są one idealne, gdy trzeba odzyskać wiele rekordów na raz.
    Przykładami takich baz danych są Redis, Memcached, KeyDB, czy DragonflyDB\footnote{S. 5 - 19; Marc Seeger, Key-Value stores: a practical overview, Computer Science and Media Ultra-Large-Sites SS09, Stuttgart, Germany, 21.09.2009r.}.
    \item Document store -- jak sama nazwa wskazuje, są to bazy danych, w których przechowywane są obiekty podobne do dokumentów.
    Dane przechowywane w takiej bazie danych są zwykle zorganizowane w formacie częściowo ustrukturyzowanym, takim jak JSON, XML lub BSON.
    Daje to programistom większą elastyczność, ponieważ schematy danych nie muszą dokładnie odpowiadać wzorcom innych dokumentów przechowywanych w danej kolekcji.
    Złożone transakcje mogą być jednak problematyczne i prowadzić do uszkodzenia danych.
    Popularne przypadki użycia baz danych dokumentów obejmują systemy zarządzania treścią i profile użytkowników.
    Przykładem bazy danych zorientowanej na dokumenty jest MongoDB\footnote{S. 337; Robin Hecht, Stefan Jablonski, NoSQL Evaluation A Use Case Oriented Survey, International Conference on Cloud and Service Computing, 2011r.}.
    \item Wide-column store -- informacje są przechowywane w kolumnach, co pozwala użytkownikom uniknąć nadmiernego i niedostatecznego pobierania, ograniczając alokację pamięci.
    Ta baza danych próbuje rozwiązać niedociągnięcia magazynów klucz-wartość i dokumentów, ale ponieważ może być bardziej złożonym systemem do zarządzania, nie jest zalecana do stosowania w nowszych zespołach i projektach.
    Apache HBase i Apache Cassandra są przykładami baz danych o otwartym kodzie źródłowym i szerokim zakresie kolumn.
    Apache HBase jest zbudowany na bazie Hadoop Distributed Files System, który zapewnia sposób przechowywania rzadkich zestawów danych, co jest powszechnie stosowane w wielu aplikacjach big data.
    Z kolei Apache Cassandra została zaprojektowana do zarządzania dużymi ilościami danych na wielu serwerach i w klastrach obejmujących wiele centrów danych.
    Jest ona wykorzystywana w różnych przypadkach, takich jak serwisy społecznościowe i analiza danych w czasie rzeczywistym\footnote{S. 118-122; K. T. Sridhar, Modern Column Stores for Big Data Processing, XtremeData Technologies, Bangalore, India, 25.11.2017 r.}.
    \item Graph store -- zwykle używany do przechowywania grafu wiedzy, w którym elementy danych są przechowywane jako węzły, krawędzie i właściwości.
    Węzłem może być dowolny obiekt, miejsce lub osoba.
    Krawędź definiuje relację między węzłami.
    Grafowe bazy danych służą do przechowywania i zarządzania siecią połączeń między elementami w ramach grafu.
    Przykładem takowej jest Neo4j, oparta na grafach usługa bazodanowa oparta na Javie z edycją społecznościową open source\footnote{S. 1548-1552; I.Fosić, K.Šolić, Graph Database Approach for Data Storing, Presentation and Manipulation, 20-24.0.52019, Opatija Croatia}.
\end{enumerate}

\textbf{Teoria CAP} \\
Tak zwana ,,teoria CAP`` oznacza spójność, dostępność lub tolerancję partycji. Relacyjne bazy danych zapewniają, że informacje są zawsze zsynchronizowane i spójne. Nie jest tak w przypadku baz danych takich jak Redis, ponieważ wolą one zawsze zapewniać odpowiedź, nawet jeżeli ma przekazać przestarzałe dane. Oznacza to, że informacje otrzymane z zapytania mogą być nieprawidłowe o kilka sekund -- być może nawet do pół minuty. Większość baz danych NoSQL pozostaje zgodna z ,,twierdzeniem CAP``, a nawet jest zgodna z ACID.\footnote{S. 10-18; Eric A. Brewer, Towards Robust Distributed Systems, PODC, 16.07.2000 r.}

\textbf{SQL\\}
SQL jest ustandaryzowanym językiem programowania służącym do interakcji z systemami zarządzania relacyjnymi bazami danych. Stworzony został przez Dona Chamberlina i Raya Boyce'a w IBM \footnote{S. 79; Donald D. Chamberlin, Early History of SQL, IEEE, 21.11.2012r}.
Pierwotnie znany jako SEQUEL, został później uproszczony do SQL, ze względu na kwestię znaku towarowego.
Jest to de facto standard relacyjnych systemów baz danych.
Jak sama nazwa wskazuje, jest to język zapytań, który służy jako pomost między bazą danych a użytkownikami.
Niezależnie od tego, czy jest to programista stojący za danym systemem, czy zwykły użytkownik, wszyscy ludzie zaznajomieni z nowoczesną technologią, nawet jeśli nieświadomie, używali SQL.
Biorąc pod uwagę, jak blisko relacyjne bazy danych są powiązane z SQL, są one powszechnie nazywane ,,bazami danych SQL``.

\subparagraph{Relacyjne bazy danych\\}
Relacyjna baza danych to, jak sama nazwa wskazuje, magazyn danych, który przechowuje je w sposób relacyjny.
Ten typ pamięci masowej rozumie i przechowuje dane w formacie tabelarycznym, tj. wierszy i kolumn.
Relacje są deklarowane za pomocą kluczy podstawowych i obcych, które służą jako identyfikatory danej relacji.
Relacje te są zwykle ilustrowane za pomocą różnych typów modeli danych.
Kolumny są traktowane jako pola przechowujące nazwę danej zmiennej (na przykład identyfikatorUżytkownika) i typ SQL, podczas gdy wiersze przechowują rzeczywiste wartości.
Relacyjne bazy danych są również zwykle powiązane z transakcyjnymi bazami danych, które uruchamiają polecenia w sekwencji znanej jako transakcja.
Wspomniana transakcja pozwala na przywrócenie zmian, gdy wystąpił błąd w dowolnym kroku procesu\footnote{S. 1079-1112; Paris C. Kanellakis, Departament Informatyki, Uniwerystet Brown, Stany Zjednoczone Ameryki, Providence, 1990r.}.\\
Transakcje mają specyficzne właściwości, które są reprezentowane przez akronim ACID\footnote{S. 1; Nishta Jatana, A Survey and Comparison of Relational and Non-Relational Database, International Journal of Engineering Research \& Technology, 06.08.2012r.}:
\begin{enumerate}[label=--]
    \item Atomiczność (eng. Atomicity) - wszystkie zmiany danych są wykonywane tak, jakby były pojedynczą operacją. Oznacza to, że wszystkie zmiany są wykonywane lub żadna z nich nie jest wykonywana.
    \item Spójność (eng. Consistency) - dane pozostają w spójnym stanie od stanu do końca, wzmacniając integralność danych.
    \item Izolacja (eng. Isolation) - stan pośredni transakcji nie jest widoczny dla innych transakcji, w wyniku czego transakcje, które działają jednocześnie, wydają się być serializowane.
    \item Trwałość (eng. Durability) - po pomyślnym zakończeniu transakcji zmiany w danych utrzymują się i nie są cofane, nawet w przypadku awarii systemu.
\end{enumerate}

\textbf{Decyzja}\\
Ponieważ projekt będzie w większości dotyczył przechwytywania i przetwarzania obrazów, jedynym realnym i efektywnym czasowo rozwiązaniem będzie system baz danych NoSQL zorientowany na dokumenty.

Plusy oraz minusy takiej decyzji są następujące:
\begin{enumerate}[label=--]
    \item zespół będzie miał większą elastyczność wprowadzania zmian;
    \item obsługa formatów multimediów będzie znacznie prostsza;
    \item zgodność z ACID będzie musiała zostać dokładnie zbadana i wdrożona;
    \item zespół będzie musiał zapoznać się z nową składnią, w zależności od wybranego systemu bazy danych, aby dostosować się do braku znajomości SQL.
\end{enumerate}

% TODO: Delete if necessaryX
\newpage
\paragraph{Warstwa komunikacji z bazą danych}
\subparagraph{Mapowanie obiektowo-relacyjne, mapowanie obiektowo-dokumentowe i budowniczy kwerend\\}
Mapery obiektowo-relacyjne, obiektowo-dokumentowe czy budowniczy kwerend są niezbędnymi narzędziami do utrzymywania deklaratywnego podejścia do komunikacji z systemem bazo-danowym.
Na rynku dostępnych jest wiele bibliotek oferujących konkurujące rozwiązania.
Zespół postanowił zbadać możliwość wykorzystania każdego z kategorii abstrakcji, celem wyłonienia najbardziej dopasowanego do potrzeb rozwiązania.
Wybór ten determinuje ilość złożoności i kodu bazowego, a także wymagania techniczne dotyczące konfiguracji bazy danych.

\textbf{Mapowanie obiektowo-relacyjne\\}
Wykorzystywanie mapowania obiektowo-relacyjnego (eng. Object Relational Mapping) to powszechna praktyka w projektach programistycznych.
Stanowi ono dodatkową warstwę abstrakcji nad sam język SQL, czy budowniczych kwerend, zapewniając automatyczną konwersję obiektów źródłowych na ich odpowiedniki zrozumiałe dla bazy danych oraz rekordów bazodanowych na obiekty.
W kontekście baz danych, mapowanie obiektowo-relacyjne można uznać za najwyższą formę abstrakcji dla komunikacji z bazą danych w środowisku serwerowym.\footnote{S. 1-4; Alexandre Torres [i inni] Twenty years of object-relational mapping: A survey on patterns, solutions, and their implications on application design, 28.09.2016r.}

W środowisku node.js pojawiło się takowych wiele, między innymi:
\begin{enumerate}[label=--]
    \item TypeORM - wykorzystujący eksperymentalne dekoratory w języku Typescript celem deklarowania schematu encji w bazie danych. Zdecydowana większość operacji jest w nim dostępna za ich pomocą.
    \item Sequelize - najstarszy na tej liście, pierwsze wzmianki na witrynie StackOverflow sięgają roku 2011. Jest on dojrzałym, pełnym funkcjonalności maperem, którego popularność odzwierciedlona jest w 1,5 miliona tygodniowych pobrań\footnote{Dane za stroną internetową (dostęp 16.11.2023r.) \url{https://www.npmjs.com/package/sequelize}}.
    \item Prisma - kontrowersyjny maper, którego operacje łączenia (eng. join) wykonywane są w sposób wirtualny, to znaczy poprzez wysłanie kilku kwerend do bazy danych i połączeniu ich wedle instrukcji użytkownika w ,,Prisma Engine``, który napisany został przy pomocy języka Rust, co zapewnia relatywne bezpieczeństwo oraz wysoką wydajność takiego rozwiązania\footnote{Dane za stroną internetową (dostęp: 16.11.2023r.)\url{https://www.prisma.io/}}.
    \item Drizzle - maper obiecujący pełne typowanie, syntax podobny do tego znanego z SQLa oraz automatyczną generację schematów za pomocą biblioteki Zod.
    \item Mikro-ORM - oparty na domniemanych transakcjach, automatycznym grupowaniu kwerend za pomocą wzorca jednostki pracy (eng. Unit of Work). Wzorowany jest na Hibernate, znanym z języka Java oraz Doctrine z PHP.\footnote{Dane za stroną internetową (dostęp: 16.11.2023r.) \url{https://mikro-orm.io/}}
\end{enumerate}

\textbf{Mapowanie obiektowo-dokumentowe\\}
Mapowanie obiektowo-dokumentowe powstało wraz z bazami NoSQL, których to system często nie posiada schematów danych.
Tak samo jak w przypadku mapowania obiektowo-relacyjnego, ma ono na celu uproszczenie interakcji pomiędzy aplikacją a bazą danych. Powstało ono w celu wyabstrakcjonowania procesu zarządznia i mapowania obiektów z ich natywnej dla bazy danych struktury, do takiej zrozumiałej przez język programowania, jak również utrzymującej konwencje programowania obiektowego.\footnote{S. 59130-59131; Alberto Hernandez Chillion [i inni], A Model-Driven Approach to Generate Schemas for Object-Document Mappers, IEEE Access, Murcja, Hiszpania}

W środowisku node.js na przestrzeni lat powstały między innymi następujące mapery obiektowo-dokumentowe:
\begin{enumerate}[label=--]
    \item mongoose - dedykowany dla bazy MongoDB mapper obiektowo-dokumentowy. Posiada wiele funkcjonalności związane z procesem wzbogacania POJO (eng. plain-old-javascript-object), ktore zapewniają walidację obiektów, dodawanie pól wirtualnych i inne.
    \item prisma - wcześniej wymieniony ORM, który posiada wsparcie dla MongoDB i funkcjonuje w trybie wymuszonej transakcyjności danych na bazie tzw. zbiorów replik (eng. replica set).
\end{enumerate}

\textbf{Budowniczy kwerend\\}
Budowniczy kwerend stanowią abstrakcję na język SQL w wybranym języku programowania.
Pozwalają one na deklaratywne tworzenie kwerend za pomocą operacji takich jak: select, insert, join, delete, update, with, where, not, etc.
Zabezpieczają programistę przed niebezpieczeństwem literówek poprzez pełne wsparcie intellisense w danym jęzku programowania oraz rozwiązują popularne problemy związane z cyberbezpieczeństwem przeprowadzania operacji na bazie danych, czego najpopularniejszym przykładem są operacje wstrzykiwania SQL`a (eng. SQL Injection)\footnote{Tony Russell-Rose, Farhad Shokraneh, Designing the Structured Search Experience: Rethinking the Query-Builder Paradigm, Uniwersytet w Londynie, 2020r. \url{https://quod.lib.umich.edu/w/weave/12535642.0003.102?view=text;rgn=main}}.

\textbf{Decyzja\\}
Wraz z wyborem bazy danych, zespół zdecydował się użyć mapera obiektowo-dokumentowego Mongoose.

Plusy oraz minusy takiej decyzji są następujące:
\begin{enumerate}[label=--]
    \item wszystkie typy danych natywne dla MongoDB będą łatwo dostępne pod ręką z intuicyjnym, przewidywalnym zachowaniem;
    \item wbudowana walidacja zmniejszy ilość wymaganego kodu standardowego;
    \item nie będzie żadnych, narzuconych przez bibliotekę, ograniczeń dotyczących samej konfiguracji bazy danych;
    \item wszystkie funkcje MongoDB będą dostępne i ukryte za interfejsami API Mongoose;
    \item polecenia będą buforowane na wypadek awarii lub ponownego uruchomienia bazy danych;
    \item bezpieczeństwo typów będzie trudniejsze do utrzymania;
    \item dogłębna znajomość tego narzędzia będzie niezbędna, celem pełnego wykorzystania jego możliwości;
    \item brak wbudowanego GUI, służącego jako swoisty debugger -- złagodzone za pomocą MongoDB Atlas.
\end{enumerate}

\subsubsection{Aplikacja mobilna}

\subparagraph{Wybór technologii\\}
Zespół stanął przed wyborem odpowiedniej technologii do stworzenia aplikacji mobilnej. Przy podejmowaniu decyzji należy wziąć pod uwagę umiejętności zespołu, okres czasu, w którym projekt musi zostać stworzony oraz możliwość wdrożenia niezbędnych funkcjonalności.

\textbf{Javascript -- Ionic 6\\}
Ionic 6 to framework typu open-source do tworzenia aplikacji mobilnych i desktopowych przy użyciu języków programowania sieciowego, takich jak HTML, CSS i JavaScript. Bazuje on na platformie Angular i wykorzystuje komponenty UI oparte na bibliotece Ionic, pozwalając na tworzenie atrakcyjnych i responsywnych aplikacji. Ionic 6 oferuje wiele wbudowanych funkcjonalności i narzędzi, które ułatwiają proces tworzenia i wdrażania aplikacji. \footnote{S. 3181 - 3182; Priyanka Chaudhary, IONIC FRAMEWORK, International Research Journal of Engineering and Technology (IRJET), 05.2018}
Zalety:
\begin{enumerate}[label=--]
    \item łatwość i szybkość tworzenia aplikacji dzięki wykorzystaniu języków programowania webowego, takich jak HTML, CSS i JavaScript;
    \item możliwość tworzenia natywnych aplikacji mobilnych na różne platformy, w tym iOS i Android, a także aplikacji desktopowych;
    \item wbudowane narzędzia do testowania i debugowania kodu, co ułatwia proces tworzenia i utrzymywania aplikacji;
    \item duża społeczność deweloperów i rozwijająca się platforma, co oznacza, że istnieje wiele narzędzi, wtyczek i bibliotek, które ułatwiają proces tworzenia aplikacji; \footnote{Dane za stroną internetową (dostęp 21.11.2023r.) \url{https://www.npmjs.com/package/@ionic/cli}}
    \item dostęp do wielu wbudowanych komponentów UI opartych na bibliotece Ionic, co pozwala na tworzenie atrakcyjnych i responsywnych aplikacji.
\end{enumerate}

Wady:
\begin{enumerate}[label=--]
    \item w porównaniu do innych popularnych frameworków, takich jak React Native czy Flutter, aplikacje Ionic 6 mogą cechować się gorszą wydajnością ze względu na wykorzystanie technologii webowych;
    \item brak w pełni natywnej wydajności, co może wpływać na szybkość działania aplikacji, szczególnie w przypadku bardziej złożonych aplikacji;
    \item możliwe trudności w dostosowaniu aplikacji do różnych platform, co może wymagać dodatkowych prac programistycznych.
\end{enumerate}

\textbf{Javascript -- React Native\\}
React Native to oparty na JavaScript framework do tworzenia aplikacji mobilnych, który umożliwia programistom tworzenie natywnych aplikacji mobilnych na platformy iOS i Android przy użyciu jednej bazy kodu.
Opiera się on na bibliotece ReactJS i wykorzystuje kombinację JavaScript i natywnego kodu do tworzenia wysokowydajnych aplikacji mobilnych.
React Native pozwala programistom na ponowne wykorzystanie kodu na różnych platformach, co pomaga zaoszczędzić czas i zasoby. \footnote{S. 10 - 11; William Danielsson, React Native application development – A comparison between native Android and React Native, Szwecja, Linköpings universitet, 2016}

Zalety:
\begin{enumerate}[label=--]
    \item szybkie tworzenie aplikacji dzięki wykorzystaniu JavaScript i popularnej biblioteki React;
    \item możliwość tworzenia natywnych aplikacji mobilnych z jedną bazą kodu dla różnych systemów operacyjnych;
    \item łatwa konserwacja i skalowalność aplikacji dzięki wykorzystaniu komponentów UI wielokrotnego użytku, które mogą być używane w różnych systemach operacyjnych;
    \item dostęp do natywnych funkcji systemu operacyjnego poprzez architekturę ,,bridge``; \footnote{S. 154; Sreekanth Dekkati, Karu Lal, Harshith Desamsetti, React Native for Android: Cross-Platform Mobile Application Development, Global Disclosure of Economics and Business, 12.2019}
    \item łatwe wdrażanie aktualizacji i zmian aplikacji bez konieczności weryfikacji w sklepie z aplikacjami, która jest wymagana w przypadku aplikacji natywnych; \footnote{S. 42; Hugo Hutri, COMPARISON OF REACT NATIVE AND EXPO, Finlandia, Lappeenranta–Lahti University of Technology LUT, 2023}
    \item duża społeczność deweloperów i liczne zasoby online, które ułatwiają rozwiązywanie problemów i znajdowanie gotowych rozwiązań. \footnote{Dane za stroną internetową (dostęp 21.11.2023r.) \url{https://www.npmjs.com/package/react-native}}
\end{enumerate}

Wady:
\begin{enumerate}[label=--]
    \item niższa wydajność w porównaniu do natywnych aplikacji mobilnych, zwłaszcza w przypadku bardziej złożonych i wymagających aplikacji;
    \item niektóre natywne funkcjonalności mogą być trudne lub niemożliwe do osiągnięcia w React Native, co może wymagać stworzenia dodatkowego natywnego kodu;
    \item potrzeba znajomości natywnych systemów operacyjnych i ich różnic w celu tworzenia zoptymalizowanych aplikacji dla każdej platformy;
    \item wyższa krzywa uczenia się dla początkujących programistów, którzy muszą nauczyć się zarówno JavaScript, jak i architektury React Native.
\end{enumerate}

\textbf{Flutter\\}
Flutter to otwartoźródłowy framework do tworzenia aplikacji mobilnych opracowany przez Google. Wykorzystuje on język programowania Dart, który zapewnia szybkość i wydajność, a także zaawansowane narzędzia deweloperskie i obsługę wielu platform. Flutter pozwala na tworzenie aplikacji mobilnych z eleganckimi i atrakcyjnymi interfejsami użytkownika oraz oferuje wiele wbudowanych funkcjonalności i bibliotek, które sprawiają, że tworzenie aplikacji jest szybkie i łatwe. \footnote{S. 6; Wenhao Wu, React Native vs Flutter, cross-platform mobile application frameworks, Finlandia, Metropolia University of Applied Sciences, 01.03.2018}
    
Zalety:
\begin{enumerate}[label=--]
    \item możliwość tworzenia natywnych aplikacji mobilnych na różne platformy, w tym iOS i Android, a także aplikacji webowych i desktopowych;
    \item możliwość tworzenia pięknych i atrakcyjnych interfejsów użytkownika z wykorzystaniem biblioteki Material Design oraz narzędzi do tworzenia animacji i efektów wizualnych;
    \item szybkie wdrażanie zmian i aktualizacji dzięki narzędziom Hot Reload, które pozwalają na szybkie testowanie i modyfikowanie kodu bez ponownego uruchamiania aplikacji;
    \item wbudowane narzędzia do testowania i debugowania kodu, co ułatwia proces tworzenia i utrzymania aplikacji.
\end{enumerate}

Wady:
\begin{enumerate}[label=--]
 \item mniejsza społeczność deweloperów w porównaniu do innych popularnych frameworków, takich jak React Native czy Ionic;
 \item nieco większe rozmiary plików aplikacji ze względu na wykorzystanie wbudowanych bibliotek i narzędzi;
 \item brak w pełni natywnej wydajności w porównaniu do aplikacji napisanych w językach natywnych, takich jak Java lub Kotlin dla Androida i Objective-C lub Swift dla iOS.
\end{enumerate}

\textbf{Języki natywne\\}
Programowanie aplikacji mobilnych przy użyciu języków natywnych odnosi się do tworzenia aplikacji przy użyciu języków i narzędzi dostarczanych przez platformę, dla której aplikacja jest tworzona. Na przykład aplikacje na iOS mogą być pisane w języku Swift lub Objective-C, podczas gdy aplikacje na Androida mogą być pisane w języku Kotlin lub Java.
    
Zalety:
\begin{enumerate}[label=--]
    \item wysoka wydajność: Aplikacje natywne mają dostęp do pełnych możliwości platformy, co może skutkować szybszym i płynniejszym działaniem w porównaniu do aplikacji zbudowanych przy użyciu wieloplatformowych frameworków; \footnote{S. 27; Matilda Olsson, A Comparison of Performance and Looks Between Flutter and Native Applications, Szwecja, Blekinge Institute of Technology, 13.06.2020}
    \item lepsze doświadczenie użytkownika: Aplikacje natywne mogą wykorzystywać komponenty interfejsu użytkownika specyficzne dla platformy, co zapewnia bardziej dopracowane i płynne wrażenia użytkownika;
    \item dostęp do funkcji urządzenia: Twórcy aplikacji natywnych mają dostęp do funkcji i możliwości specyficznych dla urządzenia, takich jak GPS, kamera i mikrofon, co pozwala im tworzyć aplikacje z zaawansowanymi funkcjami; \footnote{S. 16; Matilda Olsson, A Comparison of Performance and Looks Between Flutter and Native Applications}
    \item solidne narzędzia deweloperskie: Zarówno iOS, jak i Android zapewniają kompleksowe narzędzia programistyczne, w tym zintegrowane środowiska programistyczne (eng. IDE), narzędzia do debugowania i struktury do testowania aplikacji;
    \item wykorzystanie zaawansowanych możliwości uczenia maszynowego dzięki integracji z Core ML oraz optymalizacja dla Neural Engine w urządzeniach Apple, co pozwala na wydajne i efektywne wykonywanie zadań związanych z AI, takich jak rozpoznawanie obrazu, przetwarzanie języka naturalnego czy analiza danych. \footnote{ Dane za stroną internetową (dostęp 20.11.2023) \url{https://developer.apple.com/documentation/coreml} }
\end{enumerate}

Wady:
\begin{enumerate}[label=--]
    \item dłuższy czas programowania: Tworzenie aplikacji przy użyciu języków natywnych może być czasochłonnym procesem, ponieważ programiści muszą pisać oddzielne bazy kodu dla każdej platformy; \footnote{S. 26 - 27; Matilda Olsson, A Comparison of Performance and Looks Between Flutter and Native Applications}
    \item ograniczona przenośność: Aplikacje natywne są powiązane z konkretną platformą, co może ograniczać możliwość ich przenoszenia na inne platformy;
    \item stroma krzywa uczenia się: Nauka natywnych języków i narzędzi programistycznych może być trudnym i czasochłonnym procesem, szczególnie dla programistów, którzy są nowicjuszami w tworzeniu aplikacji mobilnych.
\end{enumerate}

\textbf{Decyzja\\}
Zdecydowano się na wykorzystanie natywnego dla systemów iOS języka Swift ze względu na wbudowane wsparcie Machine Learning oraz możliwość użycia Neural Engine na urządzeniach mobilnych.

\textbf{Konsekwencje\\}
Decyzja o użyciu języka Swift podczas tworzenia aplikacji mobilnej będzie miała kilka pozytywnych konsekwencji. Doprowadzi to do bardzo dobrej wydajności naszej aplikacji. Rozwiązanie zespołu będzie dostępne dla urządzeń z systemem IOS. Dzięki wsparciu Machine Learning zespół uniknie wielu problemów związanych z implementacją rozwiązania.

\subsection{Założenia teoretyczne}
\subsubsection{Model uczenia maszynowego}
%1. Architektura Modelu:
\textbf{Architektura Modelu\\}
Model opiera się na architekturze wykorzystującej głębokie sieci neuronowe.
Szczegółowo, użyto modelu opartego na konwolucyjnych sieciach neuronowych (CNN), które są skuteczne w zadaniach przetwarzania obrazów.
Wytrenowano warstwy konwolucyjne do ekstrakcji hierarchicznych cech z obrazów, a następnie zastosowano warstwy gęste do klasyfikacji.

%2. Parametry Modelu:
\textbf{Parametry modelu:}
\begin{enumerate}[label=--]
    \item liczba warstw konwolucyjnych: [X] warstw;
    \item liczba warstw gęstych: [Y] warstw;
    \item rozmiar filtrów konwolucyjnych: [Z] x [Z];
    \item funkcja aktywacji: ReLU (Rectified Linear Unit);
    \item funkcja aktywacji na wyjściu: softmax (dla wieloklasowej klasyfikacji);
    \item liczba neuronów na warstwie gęstej: [N];
    \item rozmiar batcha: [B].
\end{enumerate}

%3. Proces Nauczania Modelu:
Model został wytrenowany na zbiorze treningowym składającym się z 5000 obrazów, z podziałem 80/20 na zbiory treningowy i walidacyjny.
Proces nauczania obejmował 1000 iteracji.
Użyto algorytmu optymalizacyjnego SGD (eng. Stochastic Gradient Descent), w celu minimalizacji funkcji kosztu.
W trakcie treningu zastosowano techniki regularyzacji, takie jak dropout, aby uniknąć przetrenowania modelu.

%4. Ewaluacja Modelu:
\textbf{Ewaluacja modelu\\}
Model został oceniony na zbiorze testowym, a osiągnięta dokładność wyniosła 68\%. 
Ewaluacja obejmowała także analizę miar precyzji, czułości, specyficzności oraz F1-score, aby dostarczyć kompleksowej oceny skuteczności modelu.

%5. Użyte Technologie:
\textbf{Użyte technologie\\}
Do implementacji modelu wykorzystano technologie takie jak CoreML i Create ML, a jako ekstraktor cech użyto ,,Image Feature Print V2``. 
Te technologie umożliwiają efektywną implementację modelu na platformach Apple.

\paragraph{Preprocesowanie danych\\}
%1. Normalizacja Danych:
\textbf{Normalizacja danych\\}
Pierwszym krokiem preprocesowania danych było dostosowanie skali pikseli obrazów.
Zastosowano normalizację, aby wartości pikseli znajdowały się w zakresie od 0 do 1.
To pozwala na lepszą zbieżność w procesie uczenia i minimalizuje wpływ wartości odstających.

%2. Przycinanie i Zmiana Rozmiaru:
Obrazy zostały poddane przycinaniu i zmianie rozmiaru, aby dostosować je do jednolitego formatu wejściowego modelu.
To kroki mające na celu unifikację danych wejściowych, co ułatwia proces uczenia.

%3. Usuwanie Zniekształceń:
Aby zapobiec wprowadzeniu zniekształceń, które nie mają istotnego znaczenia dla rozpoznawania obrazów, zastosowano techniki usuwania szumów i filtry wygładzające.
Działa to zarówno na korzyść procesu uczenia, jak i na efektywność modelu.

%4. Konwersja Do Formatu Wejściowego Modelu:
Model wymagał, aby dane były w odpowiednim formacie, który umożliwia technologiom takim jak CoreML efektywne ich przetwarzanie.
Zastosowano konwersję obrazów do formatu zgodnego z wymaganiami modelu.

%5. Etykietowanie Danych:
Ważnym krokiem było przypisanie etykiet do obrazów, co umożliwiło modelowi uczenie się odnośnie do różnych klas obiektów.
Etykiety były integralną częścią zbioru danych treningowych.

%6. Augmentacja Danych:
W celu zwiększenia zróżnicowania danych treningowych i poprawy zdolności generalizacji modelu, zastosowano techniki augmentacji danych, takie jak obracanie, odbijanie lustrzane czy zmiana jasności.

\paragraph{Dobór kluczowych cech szczególnych\\}
%1. Wykorzystanie Ekstraktora Cech "Image Feature Print V2":
\textbf{Ekstraktor cech\\}
W ramach tej pracy inżynierskiej zdecydowano się na skorzystanie z ,,Image Feature Print V2`` jako ekstraktora cech.
Ten ekstraktor pozwala na automatyczne wydobycie istotnych cech z obrazów, co jest szczególnie ważne w kontekście uczenia maszynowego.

%2. Analiza Hierarchii Cech:
Przed rozpoczęciem procesu uczenia modelu, przeprowadzono analizę hierarchii cech w ramach ekstraktora.
Skoncentrowano się na identyfikacji cech o różnym stopniu skomplikowania, zaczynając od prostych, takich jak krawędzie, a kończąc na bardziej abstrakcyjnych, reprezentujących bardziej złożone struktury.

%3. Selekcja Istotnych Regionów:
Dobór kluczowych cech obejmował także selekcję istotnych regionów na obrazach.
Zidentyfikowano obszary, które są szczególnie ważne dla rozpoznawania określonych klas obiektów.
To podejście pozwalało na skupienie się na kluczowych detalach, co przyspieszało proces uczenia i poprawiało skuteczność modelu.

%4. Redukcja Wymiarowości:
W celu efektywnego przetwarzania danych, zastosowano techniki redukcji wymiarowości, takie jak PCA (Principal Component Analysis).
Pozwoliło to na zachowanie istotnych informacji przy jednoczesnej redukcji liczby cech, co było szczególnie korzystne dla wydajności modelu.

%5. Ocena Wpływu Cech na Model:
Przeprowadzono analizę wpływu poszczególnych cech na skuteczność modelu.
Cechy, które nie przynosiły znaczącego wkładu w proces rozpoznawania, były poddawane selekcji lub odrzucane, co pozwalało na zoptymalizowanie zestawu cech.

%6. Adaptacja do Specyfiki Problemu:
Dobór cech był dostosowany do specyfiki problemu rozpoznawania obrazów.
Na przykład, w przypadku konkretnego zadania, kluczowe mogą być kształty, tekstury lub charakterystyczne punkty na obiektach.

%7. Ocena Stabilności Cech:
Cechy wybrane do procesu uczenia były również oceniane pod kątem stabilności. Stabilne cechy mają tendencję do lepszego generalizowania się na nowe dane, co wpływa na zdolność modelu do skutecznego rozpoznawania obrazów spoza zbioru treningowego.

\paragraph{Dobór algorytmów uczenia maszynowego\\}
%1. Analiza Zadania i Danych:
Przed dokonaniem wyboru algorytmów, dokonano analizy samego zadania rozpoznawania obrazów oraz charakterystyki zbioru danych.
Wartościowe informacje obejmowały rodzaj klasyfikacji (binarna, wieloklasowa), rozmiar danych, ich złożoność oraz możliwość istnienia nieliniowych zależności.

%2. Wybór Algorytmów Konwolucyjnych:
Ze względu na specyfikę zadania rozpoznawania obrazów, zdecydowano się na wykorzystanie algorytmów konwolucyjnych (CNN).
Algorytmy te są efektywne w przetwarzaniu obrazów, zdolne do automatycznego wyodrębniania hierarchicznych cech z danych.

%3. Wykorzystanie CoreML i Create ML:
Zdecydowano się na technologie takie jak CoreML i Create ML, które są zoptymalizowane pod kątem platform Apple.
Umożliwiają one skuteczne implementowanie modeli opartych na algorytmach CNN na urządzeniach mobilnych.

%4. Zastosowanie Feature Extractora "Image Feature Print V2":
Feature Extractor ,,Image Feature Print V2`` został użyty do automatycznego wydobycia kluczowych cech z obrazów.
Jego wybór był związany z założeniem, że odpowiednie cechy istotnie wpłyną na skuteczność modelu.

%5. Tunele Hiperparametru:
Przeprowadzono proces tunelowania hiperparametrów, takich jak współczynniki uczenia, liczba warstw konwolucyjnych, liczba neuronów w warstwach gęstych itp.
Optymalizacja hiperparametrów była kluczowym elementem w dostosowaniu modelu do konkretnego zadania.

%6. Ocena Algorytmów Klasyfikacyjnych:
W ramach analizy wydajności algorytmów, dokonano oceny różnych modeli klasyfikacyjnych dostępnych w bibliotekach machine learning.
Oceniano ich zdolność do radzenia sobie z danymi treningowymi i walidacyjnymi oraz ich skuteczność w rozpoznawaniu różnych klas.

%7. Rozważanie Wersji Ensemble:
Rozważono również użycie technik Ensemble, takich jak połączenie wielu modeli w celu poprawy ogólnej skuteczności.
Możliwe było zastosowanie kombinacji modeli konwolucyjnych i innych algorytmów.

%8. Analiza Wydajności na Platformie Apple:
Ponieważ model miał być implementowany na platformie Apple, uwzględniono specyfiki tego środowiska.
Sprawdzono, czy wybrane algorytmy i technologie są zoptymalizowane pod kątem wydajności na urządzeniach 
mobilnych.

\paragraph{Proces nauczania modelu\\}
%1. Podział Danych:
Zbiór danych został podzielony na zbiór treningowy i zbiór walidacyjny w proporcji 80/20.
Zbiór treningowy posłużył do nauczania modelu, podczas gdy zbiór walidacyjny był wykorzystywany do monitorowania jego skuteczności na danych nieuczonych.

%2. Inicjalizacja Modelu:
Model został zainicjowany zgodnie z wybraną architekturą. W przypadku algorytmów konwolucyjnych, wagi są zazwyczaj losowo inicjowane, a następnie dostosowywane w trakcie procesu uczenia.

%3. Definicja Funkcji Kosztu:
Funkcja kosztu została zdefiniowana, oceniając różnicę między prognozami modelu a rzeczywistymi etykietami w zbiorze treningowym.
Wartość tej funkcji jest minimalizowana w trakcie procesu optymalizacji.

%4. Wybór Algorytmu Optymalizacyjnego:
Algorytm optymalizacyjny, tak jak SGD (Stochastic Gradient Descent), został wybrany do minimalizacji funkcji kosztu.
Dobór współczynnika uczenia był przedmiotem optymalizacji, aby zapewnić szybkie, ale stabilne dostosowanie wag modelu.

%5. Przeprowadzenie Iteracji:
Proces uczenia składał się z iteracji, gdzie dla każdego batcha danych model aktualizował wagi, aby lepiej dopasować się do charakterystyki zbioru treningowego.
Liczba iteracji była ustalona na 1000, co pozwalało na wystarczającą liczbę aktualizacji.

%6. Techniki Regularyzacji:
Zastosowano techniki regularyzacji, takie jak dropout, które pomagały w zapobieganiu przetrenowaniu modelu.
Dropout polega na losowym wyłączaniu pewnych neuronów w trakcie treningu, co poprawia zdolność generalizacji modelu.

%7. Monitorowanie Skuteczności:
Podczas procesu nauczania monitorowano skuteczność modelu na zbiorze walidacyjnym.
Oceniano miary takie jak dokładność, precyzja, recall i F1-score. %recall i F1-score trzeba będzie jakoś przetłumaczyć
To pozwalało na ocenę, czy model generalizuje się dobrze na nowe dane.

%8. Ewaluacja i Optymalizacja:
Po zakończeniu procesu nauczania, model został oceniony na zbiorze testowym. Analizowano wyniki, identyfikując obszary poprawy.
Możliwe było także dalsze dostosowywanie hiperparametrów w celu optymalizacji modelu.
\subsection{Opis sytuacji faktycznej}
% TODO cały zespół

% TODO: Embed in the mobile section
\begin{figure}[h]
    \centering
    \caption{Widoki aplikacji mobilnej w formie diagramu przepływu}
    \includegraphics[width=13.5cm]{./MobileAppFlows.png}
    \\Źródło: Opracowanie własne
\end{figure}

\subsection{Badania empiryczne/Inne}
% TODO cały zespół
\section{Zadania w projekcie}

\newpage

\begin{longtblr}[
    caption = {Zadania w projekcie}
]{| p{0.2\textwidth}| p{0.4\textwidth}| p{0.3\textwidth}|}
    \hline
    Cele szczegółowe projektu & Zadania w projekcie oraz termin rozpoczęcia i zakończenia realizacji zadania                                                                                    & Osoby zaangażowane w realizację zadania \\
    \hline
    {Cel 1:\\Przygotowanie modeli uczenia maszynowego} & Zadanie 1: Zebranie danych kontekstowych & 1. Kacper Bylicki \\
    {} & Zadanie 2: Przygotowanie danych treningowych & {1. Kacper Bylicki\\2. Jakub Barczewski\\3. Marek Gerszendorf}\\
    {} & {Zadanie 3: Dobranie algorytmów uczenia maszynowego\\} & {1. Kacper Bylicki\\2. Jakub Barczewski} \\
    {} & {Zadanie 4: Zaimplementowanie algorytmów uczenia maszynowego\\} & {1. Kacper Bylicki\\2. Jakub Barczewski}\\
    {} & Zadanie 5: Przeprowadzenie testów i poprawek & {1. Kacper Bylicki}\\
    \hline
    {Cel 2:\\Przygotowanie aplikacji serwerowej sterującej algorytmami uczenia maszynowego} & Zadanie 1: Stworzenie diagramu architektury aplikacji & {1. Jakub Barczewski\\2. Kacper Bylicki}\\
    {} & {Zadanie 2: Zaimplementowanie kanałów komunikacji między aplikacją serwerową a aplikacją mobilną\\} &{1. Jakub Barczewski}\\
    {} & {Zadanie 3: Przeprowadzenie testów i poprawek\\} & {1. Jakub Barczewski\\2. Kacper Bylicki\\3. Marek Gerszendorf}\\
    {} & {Zadanie 4: Dokonanie optymalizacji aplikacji\\ \\} & 1. Jakub Barczewski\\
    \hline
    {Cel 3: Przygotowanie aplikacji mobilnej} & {Zadanie 1: Stworzenie diagramu architektury aplikacji}&{1. Marek Gerszendorf}\\
    {} & Zadanie 2: Zaprojektowanie warstwy wizualnej na bazie diagramu & {1. Marek Gerszendorf\\2. Kacper Bylicki\\3. Jakub Barczewski}\\
    {} & Zadanie 3: Stworzenie prototypu aplikacji & {1. Marek Gerszendorf}\\
    {} & {Zadanie 4: Zaimplementowanie kanałów komunikacji między aplikacją a aplikacją serwerową} & {1. Marek Gerszendorf\\2. Kacper Bylicki\\3. Jakub Barczewski}\\
    {} & Zadanie 5: Przeprowadzenie testów i poprawek & {1. Marek Gerszendorf} \\
    \hline
    {Cel 4:\\Przygotowanie dokumentacji technicznej projektu} & Zadanie 1: Stworzenie diagramu architektury projektu & {1. Marek Gerszendorf\\2. Kacper Bylicki\\3. Jakub Barczewski}\\
    {} & {Zadanie 2: Rozrysowanie wzorca relacji w bazie danych (diagram ERD)}&{1. Marek Gerszendorf\\2. Kacper Bylicki\\3. Jakub Barczewski\\}\\
    {} & {Zadanie 3: Przygotowanie diagramu komunikacji aplikacji serwerowej oraz mobilnej}&{1. Marek Gerszendorf\\2. Kacper Bylicki\\3. Jakub Barczewski\\}\\
    {} & {Zadanie 4: Przygotowanie diagramu sekwencji do procesów aplikacji}&{1. Marek Gerszendorf\\2. Kacper Bylicki\\3. Jakub Barczewski\\}\\
    {} & {Zadanie 5: Stworzenie instrukcji instalacyjnej oraz developerskiej}&{1. Marek Gerszendorf\\2. Kacper Bylicki\\3. Jakub Barczewski\\}\\
    \hline
\end{longtblr}

\section{Efekty realizacji projektu}

\section{Użyteczność projektu}

\section{Autoewaluacja zespołu projektowego}

\section{Wykorzystane materiały i bibliografia związana z realizacją projektu}

%Załączniki - mają być generowane automatycznie, do ogarnięcia :)

\begin{thebibliography}{9}
    \bibitem{gus} Główny Urząd Statystyczny - Ochrona środowiska 2022, Warszawa, 2022r.
    \bibitem{eea-waste} Dane za stroną internetową (dostęp: 03.11.2023r.) \url{https://www.eea.europa.eu/en/topics/in-depth/waste-and-recycling?size=n_10_n&filters%5B0%5D%5Bfield%5D=readingTime&filters%5B0%5D%5Btype%5D=any&filters%5B0%5D%5Bvalues%5D%5B0%5D%5Bname%5D=All&filters%5B0%5D%5Bvalues%5D%5B0%5D%5BrangeType%5D=fixed&filters%5B1%5D%5Bfield%5D=issued.date&filters%5B1%5D%5Btype%5D=any&filters%5B1%5D%5Bvalues%5D%5B0%5D=Last%205%20years&filters%5B2%5D%5Bfield%5D=language&filters%5B2%5D%5Btype%5D=any&filters%5B2%5D%5Bvalues%5D%5B0%5D=en}
    \bibitem{eea-municipal} Dane za stroną internetową (dostęp: 03.11.2023r.) \url{https://www.eea.europa.eu/data-and-maps/daviz/municipal-waste-recycled-and-composted-6#tab-chart_7}
    \bibitem{markdown-arch-dec-rec} Markdown Architectural Decision Records: Format and Tool Support; Oliver Kopp, Anita Armbruster, Olaf Zimmermann, Institute for Parallel and Distributed Systems, University of Stuttgart, 2018r.
    \bibitem{server-centric-web-frameworks} Server-Centric Web Frameworks: An Overview; Iwan Vosloo and Derrick G. Kourie, University of Pretoria, ACM Computing Surveys, Vol. 40, No. 2, Artykuł 4, 2008r.
    \bibitem{express-npm-lib} Dane za stroną internetową (dostęp: 12.11.2023r.) \url{https://www.npmjs.com/package/express}
    \bibitem{architectural-styles-and-design} Roy Thomas Fielding, Architectural Styles and the Design of Network-based Software Architectures, 2000
    \bibitem{migrating-to-graphql} Gleison Brito, Thais Mombach, Marco Tulio Valente, Migrating to GraphQL: A Practical Assessment, ASERG Group, Department of Computer Science, Federal University of Minas Gerais, Brazil, 18.02.2019r.
    \bibitem{rfc-standards} Dane za stroną internetową (dostęp: 03.11.2023r.) \url{https://www.rfc-editor.org/rfc/rfc9110#name-status-codes}
    \bibitem{authorization-rest-web-services} Bojan Suzic, Bernd Prünster, Dominik Ziegler, On the structure and authorization management of RESTful web services, Graz Univeristy of Technology, Institue for Applied Information Processing and Communicationts, Graz, Austria, 2018r.
    \bibitem{early-history-of-sequel} Donald D. Chamberlin, Early History of SQL, IEEE, 21.11.2012r.
    \bibitem{survey-and-comparison-of-relational} Nishta Jatana, A Survey and Comparison of Relational and Non-Relational Database, International Journal of Engineering Research \& Technology, 06.08.2012r.
    \bibitem{elements-of-relational-database-theory} Paris C. Kanellakis, Departament Informatyki, Uniwerystet Brown, Stany Zjednoczone Ameryki, Providence, 1990r.
    \bibitem{base-analysis-of-nosql-database} Deka Ganesha Chandra, BASE Analysis of NoSQL Database, Regional Vocational Training Instutite for Women, Tura, Meghalaya, India, 19.11.2012r.
    \bibitem{key-value-store-a-practical-overview} Marc Seeger, Key-Value stores: a practical overview, Computer Science and Media Ultra-Large-Sites SS09, Stuttgart, Germany, 21.09.2009r.
    \bibitem{no-sql-evaluation-a-use-case-oriented-survey} Robin Hecht, Stefan Jablonski, NoSQL Evaluation A Use Case Oriented Survey, International Conference on Cloud and Service Computing, 2011r.
    \bibitem{modern-column-stores-for-big-data-processing} K. T. Sridhar, Modern Column Stores for Big Data Processing, XtremeData Technologies, Bangalore, India, 25.11.2017 r.
    \bibitem{towards-robust-distributed-systems} Eric A. Brewer, Towards Robust Distributed Systems, PODC, 16.07.2000 r.
    \bibitem{citekey}I.Fosić, K.Šolić, Graph Database Approach for Data Storing, Presentation and Manipulation, 20-24.0.52019, Opatija Croatia
    \bibitem{software-testing} Jiantao Pan, Software Testing, Carnegie Mellon University, Stany Zjednoczone Ameryki, Wiosna 1999
    \bibitem{jest-documentation} Dane za stroną internetową (dostęp 14.11.2023r.) \url{https://jestjs.io/docs/api}
    \bibitem{mocha-documentation} Dane za stroną internetową (dostęp 14.11.2023r.) \url{https://mochajs.org/}
    \bibitem{chai-documentation} Dane za stroną internetową (dostęp 14.11.2023r.) \url{https://www.chaijs.com/api/}
    \bibitem{efficiency-evaluation-nodejs-web-server-frameworks} Danil Demashov, Ilya Gosudarve, Efficiency Evaluation of Node.js Web-Server Frameworks, Uniwersytet ITMO, Petersburg, Rosja, 2020r.
    \bibitem{fastify-documentation} Dane za stroną internetową (dostęp 14.11.2023r.) \url{https://fastify.dev/docs/latest/Guides/}
    \bibitem{express-documentation} Dane za stroną internetową (dostęp: 14.11.2023r.) \url{https://expressjs.com/en/4x/api.html}
    \bibitem{nestjs-documentation} Dane za stroną internetową (dostęp: 14.11.2023r.) \url{https://docs.nestjs.com/}
    \bibitem{sequelize-npm-page} Dane za stroną internetową (dostęp 16.11.2023r.) \url{https://www.npmjs.com/package/sequelize}
    \bibitem{mikro-orm} Dane za stroną internetową (dostęp: 16.11.2023r.) \url{https://mikro-orm.io/}
    \bibitem{a-model-driven-approach-odms} Alberto Hernandez Chillion [i inni], A Model-Driven Approach to Generate Schemas for Object-Document Mappers, IEEE Access, Murcja, Hiszpania
    \bibitem{patterns-solutions-object-relational-mapping} Alexandre Torres [i inni] Twenty years of object-relational mapping: A survey on patterns, solutions, and their implications on application design, 28.09.2016r.
    \bibitem{query-builder-paradigm}Tony Russell-Rose, Farhad Shokraneh, Designing the Structured Search Experience: Rethinking the Query-Builder Paradigm, Uniwersytet w Londynie, 2020r. \url{https://quod.lib.umich.edu/w/weave/12535642.0003.102?view=text;rgn=main}
    \bibitem{ionic-framework} Priyanka Chaudhary, IONIC FRAMEWORK, International Research Journal of Engineering and Technology (IRJET), 05.2018
    \bibitem{ionic-npm} Dane za stroną internetową (dostęp 21.11.2023r.) \url{https://www.npmjs.com/package/@ionic/cli}
    \bibitem{react-native-application-development} William Danielsson, React Native application development – A comparison between native Android and React Native, Szwecja, Linköpings universitet, 2016
    \bibitem{bridge-react-native} Sreekanth Dekkati, Karu Lal, Harshith Desamsetti, React Native for Android: Cross-Platform Mobile Application Development, Global Disclosure of Economics and Business, 12.2019
    \bibitem{comparison-react-native-and-expo} Hugo Hutri, COMPARISON OF REACT NATIVE AND EXPO, Finlandia, Lappeenranta–Lahti University of Technology LUT, 2023
    \bibitem{react-native-npm} Dane za stroną internetową (dostęp 21.11.2023r.) \url{https://www.npmjs.com/package/react-native}
    \bibitem{react-native-vs-flutter} Wenhao Wu, React Native vs Flutter, cross-platform mobile application frameworks, Finlandia, Metropolia University of Applied Sciences, 01.03.2018
    \bibitem{flutter-native-performance} Thanh Tran, Flutter Native Performance and Expressive UI/UX, Finlandia, Metropolia University of Applied Sciences, 04.04.2023
    \bibitem{comparison-between-flutter-and-native-applications} Matilda Olsson, A Comparison of Performance and Looks Between Flutter and Native Applications, Szwecja, Blekinge Institute of Technology, 13.06.2020
    \bibitem{apple-documentation} Dane za stroną internetową (dostęp 20.11.2023) \url{https://developer.apple.com/documentation/coreml}
    
    \end{thebibliography}
\end{document}
